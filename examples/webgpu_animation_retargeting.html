<html lang="en">
	<head>
		<title>three.js webgpu - animation retargeting</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgpu - animation retargeting
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/tsl": "../build/three.webgpu.js",
					"three/debug": "../src/Three.WebGPU.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import { color, viewportUV } from 'three/tsl';

			import Stats from 'three/addons/libs/stats.module.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';

			const [ sourceModel, targetModel ] = await Promise.all([

				new Promise( ( resolve, reject ) => {

					new GLTFLoader().load( './models/gltf/Michelle.glb', resolve, undefined, reject );

				} ),

				new Promise( ( resolve, reject ) => {

					new GLTFLoader().load( './models/gltf/Pete/pete.gltf', resolve, undefined, reject );

				} )

			]);

			//

			const clock = new THREE.Clock();

			const stats = new Stats();
			document.body.appendChild( stats.dom );

			// scene
			const scene = new THREE.Scene();
			scene.backgroundNode = viewportUV.distance( .5 ).mix( color( 0x0175ad ), color( 0x02274f ) );

			const helpers = new THREE.Group();
			helpers.visible = false;
			scene.add( helpers );

			const light = new THREE.HemisphereLight( 0xe9c0a5, 0x0175ad, 3 );
			scene.add( light );

			const dirLight = new THREE.DirectionalLight( 0xfcffb5, 7 );
			dirLight.position.set( 2, 5, 2 );
			scene.add( dirLight );

			const camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 100 );
			camera.position.set( - 3, 2, 5 );

			// add models to scene
			scene.add( sourceModel.scene );
			scene.add( targetModel.scene );

			// reposition models
			sourceModel.scene.position.x -= 1;
			targetModel.scene.position.x += 1;

			// hip offset
			targetModel.scene.position.y -= 1;

			// remove pete's helmet, shield, and sword
			targetModel.scene.remove( targetModel.scene.children[ 1 ] );
			targetModel.scene.remove( targetModel.scene.children[ 1 ] );
			targetModel.scene.remove( targetModel.scene.children[ 1 ] );

			// retarget
			const source = getSource( sourceModel );
			const mixer = retargetModel( source, targetModel );

			// renderer
			const renderer = new THREE.WebGPURenderer( { antialias: true } );
			renderer.toneMapping = THREE.NeutralToneMapping;
			renderer.setAnimationLoop( animate );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

			const controls = new OrbitControls( camera, renderer.domElement );
			controls.target.set( 0, 1, 0 );
			controls.update();
			controls.enablePan = true;
			controls.enableDamping = true;

			const gui = new GUI();
			gui.add( helpers, 'visible' ).name( 'helpers' );

			//

			function getSource( sourceModel ) {

				const clip = sourceModel.animations[ 0 ]

				const sourceSkin = sourceModel.scene.children[ 0 ].children[ 0 ];

				const helper = new THREE.SkeletonHelper( sourceModel.scene );
				helpers.add( helper );

				const skeleton = new THREE.Skeleton( helper.bones );

				const mixer = new THREE.AnimationMixer( sourceModel.scene );
				mixer.clipAction( sourceModel.animations[ 0 ] ).play();

				return { clip, helper, skeleton, mixer };

			}

			function retargetModel( sourceModel, targetModel ) {

				const targetSkin = targetModel.scene.children[ 0 ].children[ 0 ];

				const targetSkelHelper = new THREE.SkeletonHelper( targetModel.scene );
				helpers.add( targetSkelHelper );

				const offsetMatrix = new THREE.Matrix4().makeRotationY( THREE.MathUtils.degToRad( 180 ) );

				const retargetOptions = {

					preservePosition: true,
					preserveHipPosition: false,
					useTargetMatrix: false,

					// specify the name of the source's hip bone.
					hip: 'mixamorigHips',

					offsets: {

						upperlegl: offsetMatrix,
						lowerlegl: offsetMatrix,
						footl: offsetMatrix,

						upperlegr: offsetMatrix,
						lowerlegr: offsetMatrix,
						footr: offsetMatrix

					},

					// Map of target's bone names to source's bone names
					names: {

						hips: 'mixamorigHips',

						spine: 'mixamorigSpine',
						chest: 'mixamorigSpine2',
						head: 'mixamorigHead',

						upperarml: 'mixamorigLeftArm',
						upperarmr: 'mixamorigRightArm',
						lowerarml: 'mixamorigLeftForeArm',
						lowerarmr: 'mixamorigRightForeArm',

						upperlegl: 'mixamorigLeftUpLeg',
						upperlegr: 'mixamorigRightUpLeg',
						lowerlegl: 'mixamorigLeftLeg',
						lowerlegr: 'mixamorigRightLeg',
						footl: 'mixamorigLeftFoot',
						footr: 'mixamorigRightFoot',

					}

				};

				const retargetedClip = SkeletonUtils.retargetClip( targetSkin, sourceModel.skeleton, sourceModel.clip, retargetOptions );

				// Apply the mixer directly to the SkinnedMesh, not any
				// ancestor node, because that's what
				// SkeletonUtils.retargetClip outputs the clip to be
				// compatible with.
				const mixer = new THREE.AnimationMixer( targetSkin );
				mixer.clipAction( retargetedClip ).play();

				return mixer;

			}

			window.onresize = function () {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			};

			function animate() {

				const delta = clock.getDelta();

				source.mixer.update( delta );
				mixer.update( delta );

				controls.update();

				stats.update();

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>
