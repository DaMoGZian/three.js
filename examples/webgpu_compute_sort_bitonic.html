<html lang="en">
	<head>
		<title>three.js - WebGPU - Compute</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> WebGPU - Compute - Sort - Bitonic
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/tsl": "../build/three.webgpu.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import { storageObject, If, vec3, uniform, uv, uint, float, Fn, vec2, invocationLocalIndex, workgroupArray, uvec2, floor, instanceIndex, workgroupBarrier } from 'three/tsl';

			let currentStep = 0;
			let highestBlockHeight = 2;

			const StepType = {

				NONE: 0,
				FLIP_LOCAL: 1,
				DISPERSE_LOCAL: 2,
				FLIP_GLOBAL: 3,
				DISPERSE_GLOBAL: 4,

			};

			const size = 64;
			const gridDim = Math.sqrt( size );

			const getNumSteps = () => {

				const n = Math.log2( size );
				return ( n * ( n + 1 ) ) / 2;

			};

			const MAX_STEPS = getNumSteps();

			const WORKGROUP_SIZE = [ 64 ];

			const effectController = {
				// Sqr root of 16834
				gridWidth: uniform( gridDim ),
				gridHeight: uniform( gridDim ),
				nextBlockHeight: uniform( uint( 2 ) ),
				nextAlgo: uniform( uint( StepType.FLIP_LOCAL ) )
			};

			// WebGPU Backend
			init();

			async function init() {

				const aspect = window.innerWidth / window.innerHeight;
				const camera = new THREE.OrthographicCamera( - aspect, aspect, 1, - 1, 0, 2 );
				camera.position.z = 1;

				const scene = new THREE.Scene();

				const nextAlgoBuffer = new THREE.StorageInstancedBufferAttribute( new Uint32Array( 1 ).fill( StepType.FLIP_LOCAL ), 1 );
				const nextAlgoStorage = storageObject( nextAlgoBuffer, 'uint', nextAlgoBuffer.count );

				const nextBlockHeightBuffer = new THREE.StorageInstancedBufferAttribute( new Uint32Array( 1 ).fill( 2 ), 1 );
				const nextBlockHeightStorage = storageObject( nextBlockHeightBuffer, 'uint', nextBlockHeightBuffer.count );

				const highestBlockHeightBuffer = new THREE.StorageInstancedBufferAttribute( new Uint32Array( 1 ).fill( 2 ), 1 );
				const highestBlockHeightStorage = storageObject( highestBlockHeightBuffer, 'uint', highestBlockHeightBuffer.count );

				const array = new Uint32Array( Array.from( { length: size }, ( _, i ) => {

					return i;

				} ) );


				const randomizeDataArray = () => {

					let currentIndex = array.length;
					while ( currentIndex !== 0 ) {

						const randomIndex = Math.floor( Math.random() * currentIndex );
						currentIndex -= 1;
						[ array[ currentIndex ], array[ randomIndex ] ] = [
							array[ randomIndex ],
							array[ currentIndex ],
						];

					}

				};

				randomizeDataArray();

				const currentElementsBuffer = new THREE.StorageInstancedBufferAttribute( array, 1 );
				const currentElementsStorage = storageObject( currentElementsBuffer, 'uint', size );
				const randomizedElementsBuffer = new THREE.StorageInstancedBufferAttribute( size, 1 );
				const randomizedElementsStorage = storageObject( randomizedElementsBuffer, 'uint', size );


				const getFlipIndices = ( index, blockHeight ) => {

					const blockOffset = ( index.mul( 2 ).div( blockHeight ) ).mul( blockHeight );
					const halfHeight = blockHeight.div( 2 );
					const idx = uvec2( index.modInt( halfHeight ), blockHeight.sub( index.modInt( halfHeight ) ).sub( 1 ) );
					idx.x.addAssign( blockOffset );
					idx.y.addAssign( blockOffset );

					return idx;

				};

				const getDisperseIndices = ( index, blockHeight ) => {

					const blockOffset = ( ( index.mul( 2 ) ).div( blockHeight ) ).mul( blockHeight );
					const halfHeight = blockHeight.div( 2 );
					const idx = uvec2(
						index.modInt( halfHeight ),
						( index.modInt( halfHeight ) ).add( halfHeight )
					);

					idx.x.addAssign( blockOffset );
					idx.y.addAssign( blockOffset );

					return idx;

				};

				const compareAndSwap = ( swapBuffer, idxBefore, idxAfter ) => {

					If( swapBuffer.element( idxAfter ).lessThan( swapBuffer.element( idxBefore ) ), () => {

						const temp = swapBuffer.element( idxBefore ).toVar();
						swapBuffer.element( idxBefore ).assign( swapBuffer.element( idxAfter ) );
						swapBuffer.element( idxAfter ).assign( temp );

					} );

				};

				const setUniforms = () => {

					if ( currentStep !== MAX_STEPS ) {

						currentStep ++;

						effectController.nextBlockHeight.value = effectController.nextBlockHeight.value / 2;

						// Each cycle of a bitonic sort contains a flip operation followed by multiple disperse operations.
        		// Next Block Height will equal one when the sort needs to begin a new cycle of flip and disperse operations.
						if ( effectController.nextBlockHeight.value === 1 ) {

							// The next cycle's flip operation will have a maximum swap span 2 times that of the previous cycle
							highestBlockHeight *= 2;

							if ( highestBlockHeight === size * 2 ) {

								// The next cycle's maximum swap span exceeds the total number of elements. Therefore, the sort is over.
           	 // Accordingly, there will be no next step.

								effectController.nextAlgo.value = StepType.NONE;
								effectController.nextBlockHeight.value = 0;

							} else if ( highestBlockHeight > WORKGROUP_SIZE[ 0 ] * 2 ) {

								effectController.nextAlgo.value = StepType.FLIP_GLOBAL;
								effectController.nextBlockHeight.value = highestBlockHeight;

							} else {

								// The next cycle's maximum swap span exceeds the range of a single workgroup, so our next flip will operate on global indices.
								effectController.nextAlgo.value = StepType.FLIP_LOCAL;
								effectController.nextBlockHeight.value = highestBlockHeight;

							}

						} else {

							effectController.nextBlockHeight.value > WORKGROUP_SIZE[ 0 ] * 2
								? ( effectController.nextAlgo.value = StepType.DISPERSE_GLOBAL )
								: ( effectController.nextAlgo.value = StepType.DISPERSE_LOCAL );

						}

					}

				};

				const computeInitFn = Fn( () => {

					randomizedElementsStorage.element( instanceIndex ).assign( currentElementsStorage.element( instanceIndex ) );

				} );

				const computeBitonicStepFn = Fn( () => {

					const localStorage = workgroupArray( 'uint', 64 * 2 );

					const { nextBlockHeight, nextAlgo } = effectController;

					// Get ids of indices needed to populate workgroup local buffer.
					// Use .toVar() to prevent recalculation of values when the global buffer gets repopulated.
					const workgroupId = instanceIndex.div( WORKGROUP_SIZE[ 0 ] ).toVar();
					const localOffset = uint( WORKGROUP_SIZE[ 0 ] ).mul( 2 ).mul( workgroupId ).toVar();
					const localId1 = invocationLocalIndex.mul( 2 ).toVar();
					const localId2 = localId1.add( 1 ).toVar();

					//currentElementsStorage.element( localOffset.add( localId1 ) ).assign( currentStep );//).add( localId1 ) );
					//currentElementsStorage.element( localOffset.add( localId2 ) ).assign( currentStep );

					// If we will perform a local swap, then populate the local data
					If( nextAlgo.lessThanEqual( StepType.DISPERSE_LOCAL ), () => {

						localStorage.element( localId1 ).assign( currentElementsStorage.element( localOffset.add( localId1 ) ) );
						localStorage.element( localId2 ).assign( currentElementsStorage.element( localOffset.add( localId2 ) ) );

					} );

					workgroupBarrier();

					If( nextAlgo.equal( uint( StepType.FLIP_LOCAL ) ), () => {

						const idx = getFlipIndices( invocationLocalIndex, nextBlockHeight );
						compareAndSwap( localStorage, idx.x, idx.y );

					} ).ElseIf( nextAlgo.equal( uint( StepType.DISPERSE_LOCAL ) ), () => {

						const idx = getDisperseIndices( invocationLocalIndex, nextBlockHeight );
						compareAndSwap( localStorage, idx.x, idx.y );

					} ).ElseIf( nextAlgo.equal( uint( StepType.FLIP_GLOBAL ) ), () => {

						const idx = getFlipIndices( instanceIndex, nextBlockHeight );
						compareAndSwap( currentElementsStorage, idx.x, idx.y );

					} ).ElseIf( nextAlgo.equal( uint( StepType.DISPERSE_GLOBAL ) ), () => {

						const idx = getFlipIndices( instanceIndex, nextBlockHeight );
						compareAndSwap( currentElementsStorage, idx.x, idx.y );

					} );

					// Ensure that all invocations have swapped their own regions of data
					workgroupBarrier();

					// Populate output data with the results from our swaps
					If( nextAlgo.lessThanEqual( StepType.DISPERSE_LOCAL ), () => {

						currentElementsStorage.element( localOffset.add( localId1 ) ).assign( localStorage.element( localId1 ) );
						currentElementsStorage.element( localOffset.add( localId2 ) ).assign( localStorage.element( localId2 ) );

					} );


				} );

				const computeSetAlgoFn = Fn( () => {

					const nextBlockHeight = nextBlockHeightStorage.element( 0 ).toVar();
					const nextAlgo = nextAlgoStorage.element( 0 ).toVar();
					const highestBlockHeight = highestBlockHeightStorage.element( 0 ).toVar();

					nextBlockHeight.divAssign( 2 );

					If( nextBlockHeight.equal( 1 ), () => {

						highestBlockHeight.mulAssign( 2 );

						If( highestBlockHeight.equal( size * 2 ), () => {
			
							nextAlgo.assign( StepType.NONE );
							nextBlockHeight.assign( 0 );

						} ).ElseIf( highestBlockHeight.greaterThan( WORKGROUP_SIZE[ 0 ] * 2 ), () => {

							nextAlgo.assign( StepType.FLIP_GLOBAL );
							nextBlockHeight.assign( highestBlockHeight );

						} ).Else( () => {

							nextAlgo.assign( StepType.FLIP_LOCAL );
							nextAlgo.assign( highestBlockHeight );

						} );

					} ).Else( () => {

						nextAlgo.assign( nextBlockHeight.greaterThan( WORKGROUP_SIZE[ 0 ] * 2 ).select( StepType.DISPERSE_GLOBAL, StepType.DISPERSE_LOCAL ) );

					} );

					nextAlgoStorage.element( 0 ).assign( nextAlgo );
					nextBlockHeightStorage.element( 0 ).assign( nextBlockHeight );
					highestBlockHeightStorage.element( 0 ).assign( highestBlockHeight );

				} );

				const computeResetFn = Fn( () => {

					currentElementsStorage.element( instanceIndex ).assign( randomizedElementsStorage.element( instanceIndex ) );
			
				} );
			
				// compute

				const computeInit = computeInitFn().compute( size );
				const computeBitonicStep = computeBitonicStepFn().compute( size / 2 );
				const computeSetAlgo = computeSetAlgoFn().compute( 1 );
				const computeReset = computeResetFn().compute( size );

				const material = new THREE.MeshBasicNodeMaterial( { color: 0x00ff00 } );

				const display = Fn( () => {

					const { gridWidth, gridHeight } = effectController;

					const newUV = uv().mul( vec2( gridWidth, gridHeight ) );

					const pixel = uvec2( uint( floor( newUV.x ) ), uint( floor( newUV.y ) ) );

					const elementIndex = uint( gridWidth ).mul( pixel.y ).add( pixel.x );

					const colorChanger = currentElementsStorage.element( elementIndex );

					const subtracter = float( colorChanger ).div( gridWidth.mul( gridHeight ) );

					const color = vec3( subtracter.oneMinus() );

					return color;


				} );

				material.colorNode = display();

				const plane = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), material );
				scene.add( plane );

				const renderer = new THREE.WebGPURenderer( { antialias: false, trackTimestamp: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				document.body.appendChild( renderer.domElement );

				scene.background = new THREE.Color( 0x313131 );

				await renderer.computeAsync( computeInit );

				renderer.info.autoReset = false;

				 const stepAnimation = async function () {

					console.log( currentStep );

					renderer.info.reset();

					if ( currentStep !== MAX_STEPS ) {

						await renderer.computeAsync( computeBitonicStep );
						await renderer.computeAsync( computeSetAlgo );

					} else {

						await renderer.computeAsync( computeReset );

						currentStep = 0;
			
					}

					currentStep ++;
			
					await renderer.renderAsync( scene, camera );

					setTimeout( stepAnimation, 1000 );

				};

				stepAnimation();

				window.addEventListener( 'resize', onWindowResize );

				function onWindowResize() {

					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();

					renderer.setSize( window.innerWidth, window.innerHeight );

					renderer.render( scene, camera );

				}

			}
		</script>
	</body>
</html>