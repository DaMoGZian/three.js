<html lang="en">
	<head>
		<title>three.js - WebGPU - Compute</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> WebGPU - Compute - 300000 Points
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/tsl": "../build/three.webgpu.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import { Fn, If, uniform, storage, workgroupArray, workgroupBarrier, uv, floor, uint, float, uvec2, vec2, vec3, instanceIndex, invocationLocalIndex } from 'three/tsl';

			let camera, scene, renderer, effectController, currentStep, data, highestBlockHeight;
			let computeBitonicStep;

			const StepType = {

				NONE: 0,
				FLIP_LOCAL: 1,
				DISPERSE_LOCAL: 2,
				FLIP_GLOBAL: 3,
				DISPERSE_GLOBAL: 4,
			
			};

			const numElements = 16384;
			
			const getNumSteps = () => {

				const n = Math.log2( numElements );
				return ( n * ( n + 1 ) ) / 2;

			};

			const maxSteps = getNumSteps();

			const randomizeDataArray = () => {

				let currentIndex = data.length;
				while ( currentIndex !== 0 ) {

					const randomIndex = Math.floor( Math.random() * currentIndex );
					currentIndex -= 1;
					[ data[ currentIndex ], data[ randomIndex ] ] = [
						data[ randomIndex ],
						data[ currentIndex ],
					];

				}

			};

			const setUniforms = () => {

				if ( currentStep !== maxSteps ) {

					renderer.compute( computeBitonicStep );

					currentStep ++;

					effectController.nextBlockHeight.value = effectController.nextBlockHeight.value / 2;

					if ( effectController.nextBlockHeight.value === 1 ) {

						highestBlockHeight *= 2;
						console.log( highestBlockHeight );

						if ( highestBlockHeight === data.length * 2 ) {

							effectController.nextAlgo.value = StepType.NONE;
							effectController.nextBlockHeight.value = 0;

						} else {

							effectController.nextAlgo.value = StepType.FLIP_LOCAL;
							effectController.nextBlockHeight.value = highestBlockHeight;

						}
			
					}

				}
			
			};

			init();

			function init() {

				camera = new THREE.OrthographicCamera( - 1.0, 1.0, 1.0, - 1.0, 0, 1 );
				camera.position.z = 1;

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x333333 );

				data = new Uint32Array( Array.from( { length: numElements }, ( _, i ) => {

					return i;
			
				} ) );

				randomizeDataArray();

				const dataBuffer = new THREE.StorageBufferAttribute( data, 1 );
				const dataStorage = storage( dataBuffer, 'uint', dataBuffer.count );
				const dataRead = storage( dataBuffer, 'uint', dataBuffer.count ).toReadOnly();

				effectController = {
					// Sqr root of 16834
					gridWidth: uniform( 128 ),
					gridHeight: uniform( 128 ),
					nextBlockHeight: uniform( uint( 2 ) ),
					nextAlgo: uniform( uint( StepType.NONE ) )
				};

				// create function

				const display = Fn( () => {

					const { gridWidth, gridHeight } = effectController;

					const newUV = uv().mul( vec2( gridWidth, gridHeight ) );

					const pixel = uvec2( uint( floor( newUV.x ) ), uint( floor( newUV.y ) ) );

					const elementIndex = uint( gridWidth ).mul( pixel.y ).add( pixel.x );

					const colorChanger = dataRead.element( elementIndex );

					const subtracter = float( colorChanger ).div( gridWidth.mul( gridHeight ) );

					const color = vec3( subtracter.oneMinus() );

					return color;

			
				} );

				const getFlipIndices = ( index, blockHeight ) => {

					const blockOffset = ( index.mul( 2 ).div( blockHeight ) ).mul( blockHeight );
					const halfHeight = blockHeight.div( 2 );
					const idx = uvec2( index.modInt( halfHeight ), blockHeight.sub( index.modInt( halfHeight ) ).sub( 1 ) );
					idx.x.addAssign( blockOffset );
					idx.y.addAssign( blockOffset );

					return idx;

				};

				const getDisperseIndices = ( index, blockHeight ) => {

					const blockOffset = ( ( index.mul( 2 ) ).div( blockHeight ) ).mul( blockHeight );
					const halfHeight = blockHeight.div( 2 );
					const idx = uvec2(
						index.modInt( halfHeight ),
						( index.modInt( halfHeight ) ).add( halfHeight )
					);

					idx.x.addAssign( blockOffset );
					idx.y.addAssign( blockOffset );

				};

				const compareAndSwap = ( swapBuffer, idxBefore, idxAfter ) => {

					If( swapBuffer.element( idxAfter ).lessThan( swapBuffer.element( idxBefore ) ), () => {

						const temp = swapBuffer.element( idxBefore ).toVar();
						swapBuffer.element( idxBefore ).assign( swapBuffer.element( idxAfter ) );
						swapBuffer.element( idxAfter ).assign( temp );
			
					} );

				};
			
				computeBitonicStep = Fn( () => {

					const localStorage = workgroupArray( 'uint', 64 * 2 );

					const { nextBlockHeight, nextAlgo } = effectController;

					If( nextAlgo.lessThanEqual( StepType.DISPERSE_LOCAL ), () => {

						const idx1 = instanceIndex.mul( 2 );
						const idx2 = idx1.add( 1 );
						localStorage.element( idx1 ).assign( dataStorage.element( idx1 ) );
						localStorage.element( idx2 ).assign( dataStorage.element( idx2 ) );

					} );

					workgroupBarrier();

					If( nextAlgo.equal( uint( StepType.FLIP_LOCAL ) ), () => {

						const idx = getFlipIndices( invocationLocalIndex, nextBlockHeight );
						compareAndSwap( localStorage, idx.x, idx.y );

					} ).ElseIf( nextAlgo.equal( uint( StepType.DISPERSE_LOCAL ) ), () => {

						const idx = getDisperseIndices( invocationLocalIndex, nextBlockHeight );
						compareAndSwap( localStorage, idx.x, idx.y );
			
					} ).ElseIf( nextAlgo.equal( uint( StepType.FLIP_GLOBAL ) ), () => {

						const idx = getFlipIndices( instanceIndex, nextBlockHeight );
						compareAndSwap( dataStorage, idx.x, idx.y );
			
					} ).ElseIf( nextAlgo.equal( uint( StepType.DISPERSE_GLOBAL ) ), () => {

						const idx = getFlipIndices( instanceIndex, nextBlockHeight );
						compareAndSwap( dataStorage, idx.x, idx.y );

					} );


				} )().compute( 64 );

				const material = new THREE.MeshBasicNodeMaterial( { color: 0x00ff00 } );
				material.colorNode = display();

				const plane = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), material );
				scene.add( plane );

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				document.body.appendChild( renderer.domElement );

				w5indow.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				for (let i = 0; i < )
			
				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>