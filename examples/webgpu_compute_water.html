 <!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - compute - water</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - <span id="waterSize"></span> webgpu compute water<br/>
			Move mouse to disturb water.<br>
			'W' key toggles wireframe.
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/tsl": "../build/three.webgpu.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import Stats from 'three/addons/libs/stats.module.js';
			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
			import { color, instanceIndex, uint, property, length, clamp, vec2, cos, negate, vec3, vertexIndex, Fn, uniform, storage, storageObject, min, max, positionLocal } from 'three/tsl';

			import { SimplexNoise } from 'three/addons/math/SimplexNoise.js';

			// Texture width for simulation
			const WIDTH = 128;

			// Water size in system units
			const BOUNDS = 512;
			const BOUNDS_HALF = BOUNDS * 0.5;

			const waterMaxHeight = 10;

			let container, stats;
			let camera, scene, renderer;
			let mouseMoved = false;
			const mouseCoords = new THREE.Vector2();
			const raycaster = new THREE.Raycaster();
			let effectController;

			let waterMesh;
			let meshRay;
			let computeHeight;
			let computeSmooth;
			let smoothShader;
			const waterNormal = new THREE.Vector3();

			const NUM_SPHERES = 5;
			const spheres = [];

			const simplex = new SimplexNoise();

			init();

			function noise( x, y ) {

				let multR = waterMaxHeight;
				let mult = 0.025;
				let r = 0;
				for ( let i = 0; i < 15; i ++ ) {

					r += multR * simplex.noise( x * mult, y * mult );
					multR *= 0.53 + 0.025 * i;
					mult *= 1.25;

				}

				return r;

			}

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 3000 );
				camera.position.set( 0, 200, 350 );
				camera.lookAt( 0, 0, 0 );

				scene = new THREE.Scene();

				const sun = new THREE.DirectionalLight( 0xFFFFFF, 3.0 );
				sun.position.set( 300, 400, 175 );
				scene.add( sun );

				const sun2 = new THREE.DirectionalLight( 0x40A040, 2.0 );
				sun2.position.set( - 100, 350, - 200 );
				scene.add( sun2 );

				effectController = {
					mousePos: uniform( new THREE.Vector2( 10000, 10000 ) ),
					mouseSize: uniform( 20.0 ),
					viscosity: uniform( 0.98 ),
					heightCompensation: uniform( 0 ),
					point1: uniform( new THREE.Vector2() ),
					spheresEnabled: false
				};

				// Initialize height storage buffers
				const heightArray = new Float32Array( WIDTH * WIDTH );
				const prevHeightArray = new Float32Array( WIDTH * WIDTH );

				let p = 0;

				for ( let j = 0; j < WIDTH; j ++ ) {

					for ( let i = 0; i < WIDTH; i ++ ) {

						const x = i * 128 / WIDTH;
						const y = j * 128 / WIDTH;

						heightArray[ p ] = noise( x, y );
						prevHeightArray[ p ] = heightArray[ p ];

						p ++;

					}

				}

				const heightBufferAttribute = new THREE.StorageBufferAttribute( heightArray, 1 );
				const prevHeightBufferAttribute = new THREE.StorageBufferAttribute( prevHeightArray, 1 );

				const heightStorage = storage( heightBufferAttribute, 'float', heightBufferAttribute.count );
				const prevHeightStorage = storage( prevHeightBufferAttribute, 'float', prevHeightBufferAttribute.count );

				const heightRead = storageObject( heightBufferAttribute, 'float', heightBufferAttribute.count ).toReadOnly();
				const prevHeightRead = storageObject( prevHeightBufferAttribute, 'float', prevHeightBufferAttribute.count ).toReadOnly();

				// Initialize water normal (orientation) storage buffers
				const waterNormalArray = new Float32Array( NUM_SPHERES * 2 );
				waterNormalArray.fill( 0.0 );
				const waterNormalBufferAttribute = new THREE.StorageBufferAttribute( waterNormalArray, 2 );
				const waterNormal = storage( waterNormalBufferAttribute, 'vec2', waterNormalBufferAttribute.count );
				const waterNormalRead = storageObject( waterNormalBufferAttribute, 'vec2', waterNormalBufferAttribute.count ).toReadOnly();

				const getNeighborIndicesTSL = ( instanceIndex ) => {

					const width = uint( WIDTH );

					// Get 2-D compute coordinate from one-dimensional instanceIndex.
					const x = property( 'uint', 'indexX' ).assign( instanceIndex.modInt( width ) );
					const y = property( 'uint', 'indexY' ).assign( instanceIndex.div( width ) );

					// Emulate Clamp to Edge Wrapping of data texture access
					const leftX = property( 'uint', 'leftX' ).assign( max( 0, x.sub( 1 ) ) );
					const rightX = property( 'uint', 'rightX' ).assign( min( x.add( 1 ), width.sub( 1 ) ) );

					const bottomY = property( 'uint', 'bottomY' ).assign( max( 0, y.sub( 1 ) ) );
					const topY = property( 'uint', 'topY' ).assign( min( y.add( 1 ), width.sub( 1 ) ) );

					const westIndex = y.mul( width ).add( leftX );
					const eastIndex = y.mul( width ).add( rightX );
			
					const southIndex = bottomY.mul( width ).add( x );
					const northIndex = topY.mul( width ).add( x );

					return { northIndex, southIndex, eastIndex, westIndex };

			
				};

				computeHeight = Fn( () => {

					const { viscosity, mousePos, mouseSize } = effectController;

					const height = heightStorage.element( instanceIndex );
					const prevHeight = prevHeightStorage.element( instanceIndex );

					// Get neighbor indices
					const { northIndex, southIndex, eastIndex, westIndex } = getNeighborIndicesTSL( instanceIndex );

					const north = property( 'float', 'north' );
					north.assign( heightStorage.element( northIndex ) );
					const south = property( 'float', 'south' );
					south.assign( heightStorage.element( southIndex ) );
					const east = property( 'float', 'east' );
					east.assign( heightStorage.element( eastIndex ) );
					const west = property( 'float', 'west' ).assign( heightStorage.element( westIndex ) );

					const newHeight = ( ( north.add( south ).add( east ).add( west ) ).mul( 0.5 ).sub( prevHeight ) ).mul( viscosity );

					// Get 2-D compute coordinate from one-dimensional instanceIndex.
					const x = instanceIndex.modInt( WIDTH );
					const y = instanceIndex.div( WIDTH );

					x.mulAssign( 1 / WIDTH );
					y.mulAssign( 1 / WIDTH );

					// Mouse influence
					const mousePhase = clamp( length( ( vec2( x, y ).sub( vec2( 0.5 ) ) ).mul( BOUNDS ).sub( vec2( mousePos.x, negate( mousePos.y ) ) ) ).mul( Math.PI ).div( mouseSize ), 0.0, Math.PI );
					newHeight.addAssign( cos( mousePhase ).add( 1.0 ) ).mul( 0.28 );

					prevHeight.assign( height );
					height.assign( newHeight );

			
				} )().compute( WIDTH * WIDTH );

				computeSmooth = Fn( () => {

					const height = heightStorage.element( instanceIndex ).toVar();
					const prevHeight = prevHeightStorage.element( instanceIndex ).toVar();

					// Get neighboring height values
					const { northH, southH, eastH, westH } = getNeighborValuesTSL( instanceIndex, heightStorage );
			
					// Get neighboring prev height values
					const { northP, southP, eastP, westP } = getNeighborValuesTSL( instanceIndex, prevHeightStorage );

					height.addAssign( northH.add( southH ).add( eastH ).add( westH ) );
					prevHeight.addAssign( northP.add( southP ).add( eastP ).add( westP ) );

					heightStorage.element( instanceIndex ).assign( height.div( 5 ) );
					prevHeightStorage.element( instanceIndex ).assign( height.div( 5 ) );

				} )().compute( WIDTH * WIDTH );


				// Water Geometry corresponds with buffered compute grid.
				const waterGeometry = new THREE.PlaneGeometry( BOUNDS, BOUNDS, WIDTH - 1, WIDTH - 1 );
				// material: make a THREE.ShaderMaterial clone of THREE.MeshPhongMaterial, with customized position shader.
				const waterMaterial = new THREE.MeshPhongNodeMaterial();

				waterMaterial.lights = true;
				waterMaterial.colorNode = color( 0x0040C0 );
				waterMaterial.specularNode = color( 0x111111 );
				waterMaterial.shininess = Math.max( 50, 1e-4 );
				waterMaterial.positionNode = Fn( () => {

					// A Mesh Phong Material uses the geometry's normals to calculate its lighting.
					// Therefore, to correct the lighting, we have to reassing the normals per vertex
					// in the position shader.
					const { northIndex, southIndex, eastIndex, westIndex } = getNeighborIndicesTSL( vertexIndex );
			
					const north = heightRead.element( northIndex );
					const south = heightRead.element( southIndex );
					const east = heightRead.element( eastIndex );
					const west = heightRead.element( westIndex );

					const x = ( west.sub( east ) ).mul( WIDTH / BOUNDS );
					const y = ( south.sub( north ) ).mul( WIDTH / BOUNDS );

					return vec3( positionLocal.x, positionLocal.y, heightRead.element( vertexIndex ) );

				} )();

				// WIDTH, HEIGHT, AND BOUNDS .toFixed(1)
				waterMesh = new THREE.Mesh( waterGeometry, waterMaterial );
				waterMesh.rotation.x = - Math.PI / 2;
				waterMesh.matrixAutoUpdate = false;
				waterMesh.updateMatrix();

				scene.add( waterMesh );

				// THREE.Mesh just for mouse raycasting
				const geometryRay = new THREE.PlaneGeometry( BOUNDS, BOUNDS, 1, 1 );
				meshRay = new THREE.Mesh( geometryRay, new THREE.MeshBasicMaterial( { color: 0xFFFFFF, visible: false } ) );
				meshRay.rotation.x = - Math.PI / 2;
				meshRay.matrixAutoUpdate = false;
				meshRay.updateMatrix();
				scene.add( meshRay );


				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				container.appendChild( renderer.domElement );

				stats = new Stats();
				container.appendChild( stats.dom );

				container.style.touchAction = 'none';
				container.addEventListener( 'pointermove', onPointerMove );

				document.addEventListener( 'keydown', function ( event ) {

					// W Pressed: Toggle wireframe
					if ( event.keyCode === 87 ) {

						waterMesh.material.wireframe = ! waterMesh.material.wireframe;
						waterMesh.material.needsUpdate = true;

					}

				} );

				window.addEventListener( 'resize', onWindowResize );


				const gui = new GUI();

				/*const enableSpheres = () => {

					for ( let i = 0; i < NUM_SPHERES; i ++ ) {

						if ( spheres[ i ] ) {

							spheres[ i ].visible = effectController.spheresEnabled;

						}

					}

				}; */

				gui.add( effectController.mouseSize, 'value', 1.0, 100.0, 1.0 ).name( 'Mouse Size' );
				gui.add( effectController.viscosity, 'value', 0.9, 0.999, 0.001 ).name( 'viscosity' );


				//createSpheres();

			}


			/*function createSpheres() {

				const sphereTemplate = new THREE.Mesh( new THREE.SphereGeometry( 4, 24, 12 ), new THREE.MeshPhongMaterial( { color: 0xFFFF00 } ) );

				for ( let i = 0; i < NUM_SPHERES; i ++ ) {

					let sphere = sphereTemplate;
					if ( i < NUM_SPHERES - 1 ) {

						sphere = sphereTemplate.clone();

					}

					sphere.position.x = ( Math.random() - 0.5 ) * BOUNDS * 0.7;
					sphere.position.z = ( Math.random() - 0.5 ) * BOUNDS * 0.7;

					sphere.userData.velocity = new THREE.Vector3();

					scene.add( sphere );

					spheres[ i ] = sphere;

				}

			} */

			/*function sphereDynamics() {

				const currentRenderTarget = gpuCompute.getCurrentRenderTarget( heightmapVariable );

				readWaterLevelShader.uniforms[ 'levelTexture' ].value = currentRenderTarget.texture;

				for ( let i = 0; i < NUM_SPHERES; i ++ ) {

					const sphere = spheres[ i ];

					if ( sphere ) {

						// Read water level and orientation
						const u = 0.5 * sphere.position.x / BOUNDS_HALF + 0.5;
						const v = 1 - ( 0.5 * sphere.position.z / BOUNDS_HALF + 0.5 );
						readWaterLevelShader.uniforms[ 'point1' ].value.set( u, v );
						gpuCompute.doRenderTarget( readWaterLevelShader, readWaterLevelRenderTarget );

						renderer.readRenderTargetPixels( readWaterLevelRenderTarget, 0, 0, 4, 1, readWaterLevelImage );
						const pixels = new Float32Array( readWaterLevelImage.buffer );

						// Get orientation
						waterNormal.set( pixels[ 1 ], 0, - pixels[ 2 ] );

						const pos = sphere.position;

						// Set height
						pos.y = pixels[ 0 ];

						// Move sphere
						waterNormal.multiplyScalar( 0.1 );
						sphere.userData.velocity.add( waterNormal );
						sphere.userData.velocity.multiplyScalar( 0.998 );
						pos.add( sphere.userData.velocity );

						if ( pos.x < - BOUNDS_HALF ) {

							pos.x = - BOUNDS_HALF + 0.001;
							sphere.userData.velocity.x *= - 0.3;

						} else if ( pos.x > BOUNDS_HALF ) {

							pos.x = BOUNDS_HALF - 0.001;
							sphere.userData.velocity.x *= - 0.3;

						}

						if ( pos.z < - BOUNDS_HALF ) {

							pos.z = - BOUNDS_HALF + 0.001;
							sphere.userData.velocity.z *= - 0.3;

						} else if ( pos.z > BOUNDS_HALF ) {

							pos.z = BOUNDS_HALF - 0.001;
							sphere.userData.velocity.z *= - 0.3;

						}

					}

				}

			} */

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function setMouseCoords( x, y ) {

				mouseCoords.set( ( x / renderer.domElement.clientWidth ) * 2 - 1, - ( y / renderer.domElement.clientHeight ) * 2 + 1 );
				mouseMoved = true;

			}

			function onPointerMove( event ) {

				if ( event.isPrimary === false ) return;

				setMouseCoords( event.clientX, event.clientY );

			}

			function animate() {

				render();
				stats.update();

			}

			function render() {

				if ( mouseMoved ) {

					raycaster.setFromCamera( mouseCoords, camera );

					const intersects = raycaster.intersectObject( meshRay );

					if ( intersects.length > 0 ) {

						const point = intersects[ 0 ].point;
						effectController.mousePos.value.set( point.x, point.z );

					} else {

						effectController.mousePos.value.set( 10000, 10000 );

					}

					mouseMoved = false;

				} else {

					effectController.mousePos.value.set( 10000, 10000 );

				}

				// Do the gpu computation
				renderer.compute( computeHeight );

				if ( effectController.spheresEnabled ) {

					//sphereDynamics();

				}

				// Render
				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>
